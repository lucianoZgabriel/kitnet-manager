// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: units.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const countUnits = `-- name: CountUnits :one
SELECT COUNT(*) FROM units
`

func (q *Queries) CountUnits(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUnits)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUnitsByStatus = `-- name: CountUnitsByStatus :one
SELECT COUNT(*) FROM units
WHERE status = $1
`

func (q *Queries) CountUnitsByStatus(ctx context.Context, status UnitStatus) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUnitsByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUnit = `-- name: CreateUnit :one
INSERT INTO units (
    id,
    number,
    floor,
    status,
    is_renovated,
    base_rent_value,
    renovated_rent_value,
    current_rent_value,
    notes,
    created_at,
    updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, number, floor, status, is_renovated, base_rent_value, renovated_rent_value, current_rent_value, notes, created_at, updated_at
`

type CreateUnitParams struct {
	ID                 uuid.UUID       `json:"id"`
	Number             string          `json:"number"`
	Floor              int32           `json:"floor"`
	Status             UnitStatus      `json:"status"`
	IsRenovated        bool            `json:"is_renovated"`
	BaseRentValue      decimal.Decimal `json:"base_rent_value"`
	RenovatedRentValue decimal.Decimal `json:"renovated_rent_value"`
	CurrentRentValue   decimal.Decimal `json:"current_rent_value"`
	Notes              sql.NullString  `json:"notes"`
	CreatedAt          time.Time       `json:"created_at"`
	UpdatedAt          time.Time       `json:"updated_at"`
}

func (q *Queries) CreateUnit(ctx context.Context, arg CreateUnitParams) (Unit, error) {
	row := q.db.QueryRowContext(ctx, createUnit,
		arg.ID,
		arg.Number,
		arg.Floor,
		arg.Status,
		arg.IsRenovated,
		arg.BaseRentValue,
		arg.RenovatedRentValue,
		arg.CurrentRentValue,
		arg.Notes,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Unit
	err := row.Scan(
		&i.ID,
		&i.Number,
		&i.Floor,
		&i.Status,
		&i.IsRenovated,
		&i.BaseRentValue,
		&i.RenovatedRentValue,
		&i.CurrentRentValue,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUnit = `-- name: DeleteUnit :exec
DELETE FROM units
WHERE id = $1
`

func (q *Queries) DeleteUnit(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUnit, id)
	return err
}

const getUnitByID = `-- name: GetUnitByID :one
SELECT id, number, floor, status, is_renovated, base_rent_value, renovated_rent_value, current_rent_value, notes, created_at, updated_at FROM units
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetUnitByID(ctx context.Context, id uuid.UUID) (Unit, error) {
	row := q.db.QueryRowContext(ctx, getUnitByID, id)
	var i Unit
	err := row.Scan(
		&i.ID,
		&i.Number,
		&i.Floor,
		&i.Status,
		&i.IsRenovated,
		&i.BaseRentValue,
		&i.RenovatedRentValue,
		&i.CurrentRentValue,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUnitByNumber = `-- name: GetUnitByNumber :one
SELECT id, number, floor, status, is_renovated, base_rent_value, renovated_rent_value, current_rent_value, notes, created_at, updated_at FROM units
WHERE number = $1
LIMIT 1
`

func (q *Queries) GetUnitByNumber(ctx context.Context, number string) (Unit, error) {
	row := q.db.QueryRowContext(ctx, getUnitByNumber, number)
	var i Unit
	err := row.Scan(
		&i.ID,
		&i.Number,
		&i.Floor,
		&i.Status,
		&i.IsRenovated,
		&i.BaseRentValue,
		&i.RenovatedRentValue,
		&i.CurrentRentValue,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAvailableUnits = `-- name: ListAvailableUnits :many
SELECT id, number, floor, status, is_renovated, base_rent_value, renovated_rent_value, current_rent_value, notes, created_at, updated_at FROM units
WHERE status = 'available'
ORDER BY floor ASC, number ASC
`

func (q *Queries) ListAvailableUnits(ctx context.Context) ([]Unit, error) {
	rows, err := q.db.QueryContext(ctx, listAvailableUnits)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Unit{}
	for rows.Next() {
		var i Unit
		if err := rows.Scan(
			&i.ID,
			&i.Number,
			&i.Floor,
			&i.Status,
			&i.IsRenovated,
			&i.BaseRentValue,
			&i.RenovatedRentValue,
			&i.CurrentRentValue,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnits = `-- name: ListUnits :many
SELECT id, number, floor, status, is_renovated, base_rent_value, renovated_rent_value, current_rent_value, notes, created_at, updated_at FROM units
ORDER BY floor ASC, number ASC
`

func (q *Queries) ListUnits(ctx context.Context) ([]Unit, error) {
	rows, err := q.db.QueryContext(ctx, listUnits)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Unit{}
	for rows.Next() {
		var i Unit
		if err := rows.Scan(
			&i.ID,
			&i.Number,
			&i.Floor,
			&i.Status,
			&i.IsRenovated,
			&i.BaseRentValue,
			&i.RenovatedRentValue,
			&i.CurrentRentValue,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnitsByFloor = `-- name: ListUnitsByFloor :many
SELECT id, number, floor, status, is_renovated, base_rent_value, renovated_rent_value, current_rent_value, notes, created_at, updated_at FROM units
WHERE floor = $1
ORDER BY number ASC
`

func (q *Queries) ListUnitsByFloor(ctx context.Context, floor int32) ([]Unit, error) {
	rows, err := q.db.QueryContext(ctx, listUnitsByFloor, floor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Unit{}
	for rows.Next() {
		var i Unit
		if err := rows.Scan(
			&i.ID,
			&i.Number,
			&i.Floor,
			&i.Status,
			&i.IsRenovated,
			&i.BaseRentValue,
			&i.RenovatedRentValue,
			&i.CurrentRentValue,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnitsByStatus = `-- name: ListUnitsByStatus :many
SELECT id, number, floor, status, is_renovated, base_rent_value, renovated_rent_value, current_rent_value, notes, created_at, updated_at FROM units
WHERE status = $1
ORDER BY floor ASC, number ASC
`

func (q *Queries) ListUnitsByStatus(ctx context.Context, status UnitStatus) ([]Unit, error) {
	rows, err := q.db.QueryContext(ctx, listUnitsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Unit{}
	for rows.Next() {
		var i Unit
		if err := rows.Scan(
			&i.ID,
			&i.Number,
			&i.Floor,
			&i.Status,
			&i.IsRenovated,
			&i.BaseRentValue,
			&i.RenovatedRentValue,
			&i.CurrentRentValue,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUnit = `-- name: UpdateUnit :one
UPDATE units
SET
    number = $2,
    floor = $3,
    status = $4,
    is_renovated = $5,
    base_rent_value = $6,
    renovated_rent_value = $7,
    current_rent_value = $8,
    notes = $9,
    updated_at = $10
WHERE id = $1
RETURNING id, number, floor, status, is_renovated, base_rent_value, renovated_rent_value, current_rent_value, notes, created_at, updated_at
`

type UpdateUnitParams struct {
	ID                 uuid.UUID       `json:"id"`
	Number             string          `json:"number"`
	Floor              int32           `json:"floor"`
	Status             UnitStatus      `json:"status"`
	IsRenovated        bool            `json:"is_renovated"`
	BaseRentValue      decimal.Decimal `json:"base_rent_value"`
	RenovatedRentValue decimal.Decimal `json:"renovated_rent_value"`
	CurrentRentValue   decimal.Decimal `json:"current_rent_value"`
	Notes              sql.NullString  `json:"notes"`
	UpdatedAt          time.Time       `json:"updated_at"`
}

func (q *Queries) UpdateUnit(ctx context.Context, arg UpdateUnitParams) (Unit, error) {
	row := q.db.QueryRowContext(ctx, updateUnit,
		arg.ID,
		arg.Number,
		arg.Floor,
		arg.Status,
		arg.IsRenovated,
		arg.BaseRentValue,
		arg.RenovatedRentValue,
		arg.CurrentRentValue,
		arg.Notes,
		arg.UpdatedAt,
	)
	var i Unit
	err := row.Scan(
		&i.ID,
		&i.Number,
		&i.Floor,
		&i.Status,
		&i.IsRenovated,
		&i.BaseRentValue,
		&i.RenovatedRentValue,
		&i.CurrentRentValue,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUnitStatus = `-- name: UpdateUnitStatus :one
UPDATE units
SET
    status = $2,
    updated_at = $3
WHERE id = $1
RETURNING id, number, floor, status, is_renovated, base_rent_value, renovated_rent_value, current_rent_value, notes, created_at, updated_at
`

type UpdateUnitStatusParams struct {
	ID        uuid.UUID  `json:"id"`
	Status    UnitStatus `json:"status"`
	UpdatedAt time.Time  `json:"updated_at"`
}

func (q *Queries) UpdateUnitStatus(ctx context.Context, arg UpdateUnitStatusParams) (Unit, error) {
	row := q.db.QueryRowContext(ctx, updateUnitStatus, arg.ID, arg.Status, arg.UpdatedAt)
	var i Unit
	err := row.Scan(
		&i.ID,
		&i.Number,
		&i.Floor,
		&i.Status,
		&i.IsRenovated,
		&i.BaseRentValue,
		&i.RenovatedRentValue,
		&i.CurrentRentValue,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
