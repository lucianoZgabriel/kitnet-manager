// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: payments.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const cancelPayment = `-- name: CancelPayment :one
UPDATE payments
SET
    status = 'cancelled',
    updated_at = $2
WHERE id = $1
RETURNING id, lease_id, payment_type, reference_month, amount, status, due_date, payment_date, payment_method, proof_url, notes, created_at, updated_at
`

type CancelPaymentParams struct {
	ID        uuid.UUID `json:"id"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) CancelPayment(ctx context.Context, arg CancelPaymentParams) (Payment, error) {
	row := q.db.QueryRowContext(ctx, cancelPayment, arg.ID, arg.UpdatedAt)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.LeaseID,
		&i.PaymentType,
		&i.ReferenceMonth,
		&i.Amount,
		&i.Status,
		&i.DueDate,
		&i.PaymentDate,
		&i.PaymentMethod,
		&i.ProofUrl,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const countPayments = `-- name: CountPayments :one
SELECT COUNT(*) FROM payments
`

func (q *Queries) CountPayments(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPayments)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPaymentsByLeaseID = `-- name: CountPaymentsByLeaseID :one
SELECT COUNT(*) FROM payments
WHERE lease_id = $1
`

func (q *Queries) CountPaymentsByLeaseID(ctx context.Context, leaseID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPaymentsByLeaseID, leaseID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPaymentsByStatus = `-- name: CountPaymentsByStatus :one
SELECT COUNT(*) FROM payments
WHERE status = $1
`

func (q *Queries) CountPaymentsByStatus(ctx context.Context, status string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPaymentsByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPayment = `-- name: CreatePayment :one
INSERT INTO payments (
    id,
    lease_id,
    payment_type,
    reference_month,
    amount,
    status,
    due_date,
    payment_date,
    payment_method,
    proof_url,
    notes,
    created_at,
    updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
) RETURNING id, lease_id, payment_type, reference_month, amount, status, due_date, payment_date, payment_method, proof_url, notes, created_at, updated_at
`

type CreatePaymentParams struct {
	ID             uuid.UUID      `json:"id"`
	LeaseID        uuid.UUID      `json:"lease_id"`
	PaymentType    string         `json:"payment_type"`
	ReferenceMonth time.Time      `json:"reference_month"`
	Amount         string         `json:"amount"`
	Status         string         `json:"status"`
	DueDate        time.Time      `json:"due_date"`
	PaymentDate    sql.NullTime   `json:"payment_date"`
	PaymentMethod  sql.NullString `json:"payment_method"`
	ProofUrl       sql.NullString `json:"proof_url"`
	Notes          sql.NullString `json:"notes"`
	CreatedAt      time.Time      `json:"created_at"`
	UpdatedAt      time.Time      `json:"updated_at"`
}

func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (Payment, error) {
	row := q.db.QueryRowContext(ctx, createPayment,
		arg.ID,
		arg.LeaseID,
		arg.PaymentType,
		arg.ReferenceMonth,
		arg.Amount,
		arg.Status,
		arg.DueDate,
		arg.PaymentDate,
		arg.PaymentMethod,
		arg.ProofUrl,
		arg.Notes,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.LeaseID,
		&i.PaymentType,
		&i.ReferenceMonth,
		&i.Amount,
		&i.Status,
		&i.DueDate,
		&i.PaymentDate,
		&i.PaymentMethod,
		&i.ProofUrl,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePayment = `-- name: DeletePayment :exec
DELETE FROM payments
WHERE id = $1
`

func (q *Queries) DeletePayment(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deletePayment, id)
	return err
}

const getOverduePayments = `-- name: GetOverduePayments :many
SELECT id, lease_id, payment_type, reference_month, amount, status, due_date, payment_date, payment_method, proof_url, notes, created_at, updated_at FROM payments
WHERE status IN ('pending', 'overdue')
  AND due_date < CURRENT_DATE
ORDER BY due_date ASC
`

func (q *Queries) GetOverduePayments(ctx context.Context) ([]Payment, error) {
	rows, err := q.db.QueryContext(ctx, getOverduePayments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.LeaseID,
			&i.PaymentType,
			&i.ReferenceMonth,
			&i.Amount,
			&i.Status,
			&i.DueDate,
			&i.PaymentDate,
			&i.PaymentMethod,
			&i.ProofUrl,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentByID = `-- name: GetPaymentByID :one
SELECT id, lease_id, payment_type, reference_month, amount, status, due_date, payment_date, payment_method, proof_url, notes, created_at, updated_at FROM payments
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetPaymentByID(ctx context.Context, id uuid.UUID) (Payment, error) {
	row := q.db.QueryRowContext(ctx, getPaymentByID, id)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.LeaseID,
		&i.PaymentType,
		&i.ReferenceMonth,
		&i.Amount,
		&i.Status,
		&i.DueDate,
		&i.PaymentDate,
		&i.PaymentMethod,
		&i.ProofUrl,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPaymentWithLeaseDetails = `-- name: GetPaymentWithLeaseDetails :one
SELECT 
    p.id, p.lease_id, p.payment_type, p.reference_month, p.amount, p.status, p.due_date, p.payment_date, p.payment_method, p.proof_url, p.notes, p.created_at, p.updated_at,
    l.monthly_rent_value,
    l.payment_due_day,
    u.number as unit_number,
    t.full_name as tenant_name,
    t.phone as tenant_phone
FROM payments p
INNER JOIN leases l ON p.lease_id = l.id
INNER JOIN units u ON l.unit_id = u.id
INNER JOIN tenants t ON l.tenant_id = t.id
WHERE p.id = $1
LIMIT 1
`

type GetPaymentWithLeaseDetailsRow struct {
	ID               uuid.UUID      `json:"id"`
	LeaseID          uuid.UUID      `json:"lease_id"`
	PaymentType      string         `json:"payment_type"`
	ReferenceMonth   time.Time      `json:"reference_month"`
	Amount           string         `json:"amount"`
	Status           string         `json:"status"`
	DueDate          time.Time      `json:"due_date"`
	PaymentDate      sql.NullTime   `json:"payment_date"`
	PaymentMethod    sql.NullString `json:"payment_method"`
	ProofUrl         sql.NullString `json:"proof_url"`
	Notes            sql.NullString `json:"notes"`
	CreatedAt        time.Time      `json:"created_at"`
	UpdatedAt        time.Time      `json:"updated_at"`
	MonthlyRentValue string         `json:"monthly_rent_value"`
	PaymentDueDay    int32          `json:"payment_due_day"`
	UnitNumber       string         `json:"unit_number"`
	TenantName       string         `json:"tenant_name"`
	TenantPhone      string         `json:"tenant_phone"`
}

func (q *Queries) GetPaymentWithLeaseDetails(ctx context.Context, id uuid.UUID) (GetPaymentWithLeaseDetailsRow, error) {
	row := q.db.QueryRowContext(ctx, getPaymentWithLeaseDetails, id)
	var i GetPaymentWithLeaseDetailsRow
	err := row.Scan(
		&i.ID,
		&i.LeaseID,
		&i.PaymentType,
		&i.ReferenceMonth,
		&i.Amount,
		&i.Status,
		&i.DueDate,
		&i.PaymentDate,
		&i.PaymentMethod,
		&i.ProofUrl,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MonthlyRentValue,
		&i.PaymentDueDay,
		&i.UnitNumber,
		&i.TenantName,
		&i.TenantPhone,
	)
	return i, err
}

const getPendingAmountByLease = `-- name: GetPendingAmountByLease :one
SELECT COALESCE(SUM(amount), 0)::TEXT as total
FROM payments
WHERE lease_id = $1
  AND status IN ('pending', 'overdue')
`

func (q *Queries) GetPendingAmountByLease(ctx context.Context, leaseID uuid.UUID) (string, error) {
	row := q.db.QueryRowContext(ctx, getPendingAmountByLease, leaseID)
	var total string
	err := row.Scan(&total)
	return total, err
}

const getTotalPaidByLease = `-- name: GetTotalPaidByLease :one
SELECT COALESCE(SUM(amount), 0)::TEXT as total
FROM payments
WHERE lease_id = $1
  AND status = 'paid'
`

func (q *Queries) GetTotalPaidByLease(ctx context.Context, leaseID uuid.UUID) (string, error) {
	row := q.db.QueryRowContext(ctx, getTotalPaidByLease, leaseID)
	var total string
	err := row.Scan(&total)
	return total, err
}

const getUpcomingPayments = `-- name: GetUpcomingPayments :many
SELECT id, lease_id, payment_type, reference_month, amount, status, due_date, payment_date, payment_method, proof_url, notes, created_at, updated_at FROM payments
WHERE status = 'pending'
  AND due_date >= CURRENT_DATE
  AND due_date <= CURRENT_DATE + $1::INTEGER
ORDER BY due_date ASC
`

func (q *Queries) GetUpcomingPayments(ctx context.Context, dollar_1 int32) ([]Payment, error) {
	rows, err := q.db.QueryContext(ctx, getUpcomingPayments, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.LeaseID,
			&i.PaymentType,
			&i.ReferenceMonth,
			&i.Amount,
			&i.Status,
			&i.DueDate,
			&i.PaymentDate,
			&i.PaymentMethod,
			&i.ProofUrl,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPayments = `-- name: ListPayments :many
SELECT id, lease_id, payment_type, reference_month, amount, status, due_date, payment_date, payment_method, proof_url, notes, created_at, updated_at FROM payments
ORDER BY due_date DESC
`

func (q *Queries) ListPayments(ctx context.Context) ([]Payment, error) {
	rows, err := q.db.QueryContext(ctx, listPayments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.LeaseID,
			&i.PaymentType,
			&i.ReferenceMonth,
			&i.Amount,
			&i.Status,
			&i.DueDate,
			&i.PaymentDate,
			&i.PaymentMethod,
			&i.ProofUrl,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentsByLeaseID = `-- name: ListPaymentsByLeaseID :many
SELECT id, lease_id, payment_type, reference_month, amount, status, due_date, payment_date, payment_method, proof_url, notes, created_at, updated_at FROM payments
WHERE lease_id = $1
ORDER BY due_date ASC
`

func (q *Queries) ListPaymentsByLeaseID(ctx context.Context, leaseID uuid.UUID) ([]Payment, error) {
	rows, err := q.db.QueryContext(ctx, listPaymentsByLeaseID, leaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.LeaseID,
			&i.PaymentType,
			&i.ReferenceMonth,
			&i.Amount,
			&i.Status,
			&i.DueDate,
			&i.PaymentDate,
			&i.PaymentMethod,
			&i.ProofUrl,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentsByStatus = `-- name: ListPaymentsByStatus :many
SELECT id, lease_id, payment_type, reference_month, amount, status, due_date, payment_date, payment_method, proof_url, notes, created_at, updated_at FROM payments
WHERE status = $1
ORDER BY due_date ASC
`

func (q *Queries) ListPaymentsByStatus(ctx context.Context, status string) ([]Payment, error) {
	rows, err := q.db.QueryContext(ctx, listPaymentsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.LeaseID,
			&i.PaymentType,
			&i.ReferenceMonth,
			&i.Amount,
			&i.Status,
			&i.DueDate,
			&i.PaymentDate,
			&i.PaymentMethod,
			&i.ProofUrl,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentsWithLeaseDetails = `-- name: ListPaymentsWithLeaseDetails :many
SELECT 
    p.id, p.lease_id, p.payment_type, p.reference_month, p.amount, p.status, p.due_date, p.payment_date, p.payment_method, p.proof_url, p.notes, p.created_at, p.updated_at,
    l.monthly_rent_value,
    l.payment_due_day,
    u.number as unit_number,
    t.full_name as tenant_name,
    t.phone as tenant_phone
FROM payments p
INNER JOIN leases l ON p.lease_id = l.id
INNER JOIN units u ON l.unit_id = u.id
INNER JOIN tenants t ON l.tenant_id = t.id
ORDER BY p.due_date DESC
`

type ListPaymentsWithLeaseDetailsRow struct {
	ID               uuid.UUID      `json:"id"`
	LeaseID          uuid.UUID      `json:"lease_id"`
	PaymentType      string         `json:"payment_type"`
	ReferenceMonth   time.Time      `json:"reference_month"`
	Amount           string         `json:"amount"`
	Status           string         `json:"status"`
	DueDate          time.Time      `json:"due_date"`
	PaymentDate      sql.NullTime   `json:"payment_date"`
	PaymentMethod    sql.NullString `json:"payment_method"`
	ProofUrl         sql.NullString `json:"proof_url"`
	Notes            sql.NullString `json:"notes"`
	CreatedAt        time.Time      `json:"created_at"`
	UpdatedAt        time.Time      `json:"updated_at"`
	MonthlyRentValue string         `json:"monthly_rent_value"`
	PaymentDueDay    int32          `json:"payment_due_day"`
	UnitNumber       string         `json:"unit_number"`
	TenantName       string         `json:"tenant_name"`
	TenantPhone      string         `json:"tenant_phone"`
}

func (q *Queries) ListPaymentsWithLeaseDetails(ctx context.Context) ([]ListPaymentsWithLeaseDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, listPaymentsWithLeaseDetails)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPaymentsWithLeaseDetailsRow{}
	for rows.Next() {
		var i ListPaymentsWithLeaseDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.LeaseID,
			&i.PaymentType,
			&i.ReferenceMonth,
			&i.Amount,
			&i.Status,
			&i.DueDate,
			&i.PaymentDate,
			&i.PaymentMethod,
			&i.ProofUrl,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MonthlyRentValue,
			&i.PaymentDueDay,
			&i.UnitNumber,
			&i.TenantName,
			&i.TenantPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markPaymentAsPaid = `-- name: MarkPaymentAsPaid :one
UPDATE payments
SET
    status = 'paid',
    payment_date = $2,
    payment_method = $3,
    updated_at = $4
WHERE id = $1
RETURNING id, lease_id, payment_type, reference_month, amount, status, due_date, payment_date, payment_method, proof_url, notes, created_at, updated_at
`

type MarkPaymentAsPaidParams struct {
	ID            uuid.UUID      `json:"id"`
	PaymentDate   sql.NullTime   `json:"payment_date"`
	PaymentMethod sql.NullString `json:"payment_method"`
	UpdatedAt     time.Time      `json:"updated_at"`
}

func (q *Queries) MarkPaymentAsPaid(ctx context.Context, arg MarkPaymentAsPaidParams) (Payment, error) {
	row := q.db.QueryRowContext(ctx, markPaymentAsPaid,
		arg.ID,
		arg.PaymentDate,
		arg.PaymentMethod,
		arg.UpdatedAt,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.LeaseID,
		&i.PaymentType,
		&i.ReferenceMonth,
		&i.Amount,
		&i.Status,
		&i.DueDate,
		&i.PaymentDate,
		&i.PaymentMethod,
		&i.ProofUrl,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const markPaymentsAsOverdue = `-- name: MarkPaymentsAsOverdue :exec
UPDATE payments
SET
    status = 'overdue',
    updated_at = NOW()
WHERE status = 'pending'
  AND due_date < CURRENT_DATE
`

func (q *Queries) MarkPaymentsAsOverdue(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, markPaymentsAsOverdue)
	return err
}

const updatePayment = `-- name: UpdatePayment :one
UPDATE payments
SET
    lease_id = $2,
    payment_type = $3,
    reference_month = $4,
    amount = $5,
    status = $6,
    due_date = $7,
    payment_date = $8,
    payment_method = $9,
    proof_url = $10,
    notes = $11,
    updated_at = $12
WHERE id = $1
RETURNING id, lease_id, payment_type, reference_month, amount, status, due_date, payment_date, payment_method, proof_url, notes, created_at, updated_at
`

type UpdatePaymentParams struct {
	ID             uuid.UUID      `json:"id"`
	LeaseID        uuid.UUID      `json:"lease_id"`
	PaymentType    string         `json:"payment_type"`
	ReferenceMonth time.Time      `json:"reference_month"`
	Amount         string         `json:"amount"`
	Status         string         `json:"status"`
	DueDate        time.Time      `json:"due_date"`
	PaymentDate    sql.NullTime   `json:"payment_date"`
	PaymentMethod  sql.NullString `json:"payment_method"`
	ProofUrl       sql.NullString `json:"proof_url"`
	Notes          sql.NullString `json:"notes"`
	UpdatedAt      time.Time      `json:"updated_at"`
}

func (q *Queries) UpdatePayment(ctx context.Context, arg UpdatePaymentParams) (Payment, error) {
	row := q.db.QueryRowContext(ctx, updatePayment,
		arg.ID,
		arg.LeaseID,
		arg.PaymentType,
		arg.ReferenceMonth,
		arg.Amount,
		arg.Status,
		arg.DueDate,
		arg.PaymentDate,
		arg.PaymentMethod,
		arg.ProofUrl,
		arg.Notes,
		arg.UpdatedAt,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.LeaseID,
		&i.PaymentType,
		&i.ReferenceMonth,
		&i.Amount,
		&i.Status,
		&i.DueDate,
		&i.PaymentDate,
		&i.PaymentMethod,
		&i.ProofUrl,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePaymentStatus = `-- name: UpdatePaymentStatus :one
UPDATE payments
SET
    status = $2,
    updated_at = $3
WHERE id = $1
RETURNING id, lease_id, payment_type, reference_month, amount, status, due_date, payment_date, payment_method, proof_url, notes, created_at, updated_at
`

type UpdatePaymentStatusParams struct {
	ID        uuid.UUID `json:"id"`
	Status    string    `json:"status"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) UpdatePaymentStatus(ctx context.Context, arg UpdatePaymentStatusParams) (Payment, error) {
	row := q.db.QueryRowContext(ctx, updatePaymentStatus, arg.ID, arg.Status, arg.UpdatedAt)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.LeaseID,
		&i.PaymentType,
		&i.ReferenceMonth,
		&i.Amount,
		&i.Status,
		&i.DueDate,
		&i.PaymentDate,
		&i.PaymentMethod,
		&i.ProofUrl,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
